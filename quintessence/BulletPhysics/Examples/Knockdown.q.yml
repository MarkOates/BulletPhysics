parent_classes:


  - class: AllegroFlare::Screens::Gameplay
    scope: public
    init_with: ''


properties:


  - name: data_folder_path
    type: std::string
    init_with: '"[unset-data_folder_path]"'
    getter: true
    setter: true

  - name: dynamics_world
    type: btDiscreteDynamicsWorld*
    init_with: nullptr

  - name: dynamics_world_object
    type: BulletPhysics::DynamicsWorld*
    init_with: nullptr

  - name: sphere_body
    type: btRigidBody*
    init_with: nullptr

  - name: sphere_diameter
    type: float
    init_with: 1.25f

  - name: sphere_initial_position
    type: btVector3
    init_with: 'btVector3(0, sphere_diameter * 2, 6)'

  - name: sphere_shape
    type: btCollisionShape*
    init_with: nullptr

  - name: cube_shape
    type: btCollisionShape*
    init_with: nullptr

  - name: cubes
    type: std::vector<std::pair<btRigidBody*, btCollisionShape*>>
    init_with: '{}'

  - name: cube_initial_heights
    type: std::vector<float>
    init_with: '{}'

  - name: shape_model
    type: AllegroFlare::Model3D*
    init_with: nullptr
    setter: true

  - name: shapes
    type: std::vector<std::pair<btRigidBody*, btCollisionShape*>>
    init_with: '{}'

  - name: ground_body
    type: btRigidBody*
    init_with: nullptr

  - name: ground_shape
    type: btCollisionShape*
    init_with: nullptr

  - name: initialized
    type: bool
    init_with: false

  - name: destroyed
    type: bool
    init_with: false

  - name: state
    type: uint32_t
    init_with: STATE_UNDEF
    getter: true
    setter: explicit

  - name: state_is_busy
    type: bool
    init_with: false

  - name: state_changed_at
    type: float
    init_with: 0.0f


# Rendering-dependent properties

  - name: camera3d
    type: AllegroFlare::Camera3D
    init_with: '{}'

  - name: hud_camera
    type: AllegroFlare::Camera2D
    init_with: '{}'

  - name: model_bin
    type: AllegroFlare::ModelBin
    init_with: '{}'

  - name: bitmap_bin
    type: AllegroFlare::BitmapBin
    init_with: '{}'

  - name: font_bin
    type: AllegroFlare::FontBin
    init_with: '{}'


enums:


  - name: State
    enumerators:
      - STATE_UNDEF
      - STATE_WAITING_FOR_PLAYER_TO_THROW_BALL
      - STATE_IN_SIMULATION
      - STATE_TALLYING_SCORE
      - STATE_SCORE_TALLIED


methods:


  - name: num_cubes
    type: int
    body: |
      return cubes.size();


  - name: num_shapes
    type: int
    body: |
      return shapes.size();


  - name: clear
    guards: [ initialized ]
    body: |
      // Delete the memory elements of the cubes
      for (auto &cube : cubes)
      {
         dynamics_world->removeRigidBody(cube.first);
         delete cube.first->getMotionState(); // delete btDefaultMotionState
         delete cube.first; // delete btRigidBody
         delete cube.second; // delete btCollisionShape
      }

      // Clear the vectors
      cubes.clear();
      cube_initial_heights.clear();

      // Clear the ground plane
      dynamics_world->removeRigidBody(ground_body);
      delete ground_body->getMotionState(); // Delete the motion state
      delete ground_body; // Delete the rigid body
      delete ground_shape; // Delete the collision shape
      ground_body = nullptr;
      ground_shape = nullptr;

      // Clear the player_sphere
      dynamics_world->removeRigidBody(sphere_body); // Remove from the physics world
      delete sphere_body->getMotionState(); // Delete the motion state
      delete sphere_body; // Delete the rigid body
      delete sphere_shape; // Delete the collision shape
      sphere_body = nullptr;
      sphere_shape = nullptr;

      // For debugging purposes, output the number of bodies remaining in the dynamics_world
      int num_bodies = dynamics_world->getNumCollisionObjects();
      AllegroFlare::Logger::info_from(
         "BulletPhysics::Examples::Knockdown::clear",
          "Number of remaining rigid bodies in the dynamic_world: " + std::to_string(num_bodies)
      );


      // Delete the dynamics_world object
      // Clear our local class's dynamics_world
      dynamics_world = nullptr;
      // Destroy the dynamics_world
      dynamics_world_object->destroy();
      delete dynamics_world_object;

      return;


  - name: create_multiple_cubes
    body: |
      AllegroFlare::Random random;
      random.set_seed(123456+2);

      int num_cubes = 20;
      //btRigidBody* cube_body = nullptr;


      for (int i=0; i<num_cubes; i++)
      {
         // Create a falling cube
         btVector3 half_extents(0.5, 0.5, 0.5); // Half-dimensions of the cube (1x1x1 cube)
         btCollisionShape *cube_shape = new btBoxShape(half_extents);
         btDefaultMotionState *cube_motion_state = new btDefaultMotionState(
            btTransform(btQuaternion(0.125, random.get_random_float(0, 3.125), random.get_random_float(0, 3.125), 1),
            //btVector3(-3 + 1.5*i, 14, 0)) // Starting at position
            btVector3((-2.5 + 1.5*i)/2 + random.get_random_float(-1, 1), 15+0.75 * i, 0)) // Starting at position
         );
         btScalar cube_mass = 1;
         btVector3 cube_inertia;
         cube_shape->calculateLocalInertia(cube_mass, cube_inertia); // Calculate the cube's inertia tensor
         btRigidBody::btRigidBodyConstructionInfo cube_body_ci(
            cube_mass,
            cube_motion_state,
            cube_shape,
            cube_inertia
         );
         btRigidBody *cube_body = new btRigidBody(cube_body_ci);

         // Make the cube body bouncy
         cube_body->setRestitution(0.6);

         dynamics_world->addRigidBody(cube_body);

         cubes.push_back(
            std::pair<btRigidBody*, btCollisionShape*>(cube_body, cube_shape)
            //std::pair<cube_body, cube_shape>
         );
         //type: std::vector<std::pair<btRigidBody*, btCollisionShape*>>


         // Set initial linear velocity
         btVector3 initial_velocity(0.124, 0, 0); // Move along the x-axis
         cube_body->setLinearVelocity(initial_velocity);

         // Set initial angular velocity
         btVector3 initial_angular_velocity(
            random.get_random_int(-10, 10),
            random.get_random_int(-10, 10),
            random.get_random_int(-10, 10)
         ); // Spin around the y-axis
         cube_body->setAngularVelocity(initial_angular_velocity);

      }

      return;


  - name: create_stacked_cubes
    body: |
      //AllegroFlare::Random random;
      //random.set_seed(123456+2);

      //int num_cubes = 20;
      //btRigidBody* cube_body = nullptr;

      int num_rows = 4;
      int num_columns= 3;
      

      for (int y=0; y<num_columns; y++)
      {
         for (int x=0; x<num_rows; x++)
         {
            float pos_x = x - (num_rows * 0.5) + 0.5;
            // Define a cube height
            float cube_height = y + 1.5;

            // Create a cube
            btVector3 half_extents(0.5, 0.5, 0.5); // Half-dimensions of the cube (1x1x1 cube)
            btCollisionShape *cube_shape = new btBoxShape(half_extents);
            btDefaultMotionState *cube_motion_state = new btDefaultMotionState(
               btTransform(btQuaternion(0.0, 0.0, 0.0, 1),
               //btTransform(btQuaternion(0.125, random.get_random_float(0, 3.125), random.get_random_float(0, 3.125), 1),
               //btVector3(-3 + 1.5*i, 14, 0)) // Starting at position
               btVector3(pos_x, cube_height, 0)) // Starting at position
               //btVector3((-2.5 + 1.5*i)/2 + random.get_random_float(-1, 1), 15+0.75 * i, 0)) // Starting at position
            );
            btScalar cube_mass = 1;
            btVector3 cube_inertia;
            cube_shape->calculateLocalInertia(cube_mass, cube_inertia); // Calculate the cube's inertia tensor
            btRigidBody::btRigidBodyConstructionInfo cube_body_ci(
               cube_mass,
               cube_motion_state,
               cube_shape,
               cube_inertia
            );
            btRigidBody *cube_body = new btRigidBody(cube_body_ci);

            // Make the cube body bouncy
            cube_body->setRestitution(0.6);

            dynamics_world->addRigidBody(cube_body);

            cubes.push_back(
               std::pair<btRigidBody*, btCollisionShape*>(cube_body, cube_shape)
               //std::pair<cube_body, cube_shape>
            );
            cube_initial_heights.push_back(cube_height);
            //type: std::vector<std::pair<btRigidBody*, btCollisionShape*>>


            // Set initial linear velocity
            btVector3 initial_velocity(0, 0, 0); // Move along the x-axis
            //btVector3 initial_velocity(0.124, 0, 0); // Move along the x-axis
            cube_body->setLinearVelocity(initial_velocity);

            // Set initial angular velocity
            btVector3 initial_angular_velocity(
               0, 0, 0
               //random.get_random_int(-10, 10),
               //random.get_random_int(-10, 10),
               //random.get_random_int(-10, 10)
            ); // Spin around the y-axis
            cube_body->setAngularVelocity(initial_angular_velocity);

         }
      }

      return;


  - name: create_multiple_shapes
    body: |
      AllegroFlare::Random random;
      random.set_seed(123456+2);

      // Create multiple shapes
      //int num_shapes = 11;
      int num_shapes = 0;
      float shape_spacing = 2.25;
      for (int i=0; i<num_shapes; i++)
      {
         //shape_model
         btRigidBody* shape_body = nullptr;
         btCollisionShape* shape_shape = nullptr;

         std::tie(shape_body, shape_shape) = create_dynamic_mesh_shape(
            shape_model,
            0.0 - num_shapes * 0.5 * shape_spacing + shape_spacing * i,
            10,
            0
         );
       
         // Set initial angular velocity
         btVector3 initial_angular_velocity(
            random.get_random_int(-2, 2),
            random.get_random_int(-2, 2),
            random.get_random_int(-2, 2)
         ); // Spin around the y-axis
         shape_body->setAngularVelocity(initial_angular_velocity);

         //create_dynamic_mesh_shape
         
         // Make the cube body bouncy

         dynamics_world->addRigidBody(shape_body);

         shapes.push_back(
            std::pair<btRigidBody*, btCollisionShape*>(shape_body, shape_shape)
            //std::pair<cube_body, cube_shape>
         );
         //type: std::vector<std::pair<btRigidBody*, btCollisionShape*>>


         //// Set initial linear velocity
         //btVector3 initial_velocity(0.124, 0, 0); // Move along the x-axis
         //cube_body->setLinearVelocity(initial_velocity);

         //// Set initial angular velocity
         //btVector3 initial_angular_velocity(
            //random.get_random_int(-10, 10),
            //random.get_random_int(-10, 10),
            //random.get_random_int(-10, 10)
         //); // Spin around the y-axis
         //cube_body->setAngularVelocity(initial_angular_velocity);

      }


      return;


  - name: create_shapes_from_tmj_file
    body: |
      std::string filename = data_folder_path + "maps/" + "stack-01.tmj";
      AllegroFlare::Tiled::TMJDataLoader tmj_data_loader(filename);
      tmj_data_loader.load();

      tmj_data_loader.for_each_object([](AllegroFlare::Tiled::TMJObject* object, void* user_data){
         // HERE
         // TODO: Parse the object into a cube
      });

      return;
    body_dependency_symbols:
      - AllegroFlare::Tiled::TMJDataLoader


  - name: create
    type: BulletPhysics::Examples::Knockdown*
    body: |
      BulletPhysics::Examples::Knockdown *result = new BulletPhysics::Examples::Knockdown();
      // TODO: Put together required pieces
      return result;


  - name: initialize
    guards: [ (!initialized), (!destroyed) ]
    body: |
      // TODO: Separate the "initializing" from the creation of the elements in the world and their destruction.


      // Create a dynamics world
      dynamics_world_object = new BulletPhysics::DynamicsWorld();
      dynamics_world_object->initialize();
      dynamics_world = dynamics_world_object->get_dynamics_world();


      // Create a ground plane
      ground_shape = new btStaticPlaneShape(btVector3(0, 1, 0), 1);
      btDefaultMotionState *ground_motion_state = new btDefaultMotionState();
      btRigidBody::btRigidBodyConstructionInfo ground_body_ci(0, ground_motion_state, ground_shape, btVector3(0, 0, 0));
      ground_body = new btRigidBody(ground_body_ci);
      dynamics_world->addRigidBody(ground_body);

      // Make the ground floor body bouncy
      ground_body->setRestitution(0.8);


      // Create the player's sphere
      double diameter = sphere_diameter;
      sphere_shape = new btSphereShape(diameter); // Sphere has a size of radius of 1 (diameter of 2)
      btDefaultMotionState *sphere_motion_state = new btDefaultMotionState(
         btTransform(
            btQuaternion(0, 0, 0, 1),
            //btVector3(5, diameter * 2, 0)
            sphere_initial_position
         )
      );
      btScalar sphere_mass = 1;
      btVector3 sphere_inertia;
      sphere_shape->calculateLocalInertia(sphere_mass, sphere_inertia);
      btRigidBody::btRigidBodyConstructionInfo sphere_body_ci(
         sphere_mass,
         sphere_motion_state,
         sphere_shape,
         sphere_inertia
      );
      sphere_body = new btRigidBody(sphere_body_ci);

      // Make the sphere body bouncy
      sphere_body->setRestitution(0.8);

      dynamics_world->addRigidBody(sphere_body);



      // Add some cubes to the scene
      //create_multiple_cubes();
      create_stacked_cubes();



      // Add some shapes to the scene
      create_multiple_shapes();



      // Load objects from a TMJ file
      create_shapes_from_tmj_file();




      // Setup a player_input_controller
      auto generic_player_input_controller = new AllegroFlare::PlayerInputControllers::Generic();
      generic_player_input_controller->set_on_key_pressed([this](int key_code){
         switch (key_code)
         {
            case ALLEGRO_KEY_P: {
               // TODO: Replace this manual suspending with an "call_on_paused_callback_func()"
               call_on_paused_callback_func();
               //{
                  //if (get_gameplay_suspended()) resume_suspended_gameplay();
                  //else suspend_gameplay();
               //}
            } break;

            case ALLEGRO_KEY_SPACE: {
               AllegroFlare::Random random;
               random.set_seed(al_get_time() * 1000);
               //btVector3 initial_position(1, sphere_diameter * 2, 4);
               float x_vel = random.get_random_float(-5, 5);

               btVector3 velocity(x_vel, 0, -20);
               launch_ball(
                  &sphere_initial_position,
                  &velocity
               );
            } break;
         }
      });
      set_player_input_controller(generic_player_input_controller);


      initialized = true;



      // Initialize the rendering
      initialize_render();


      // Start the game
      set_state(STATE_WAITING_FOR_PLAYER_TO_THROW_BALL);


      return;
    body_dependency_symbols:
      - bullet_physics_common
      - AllegroFlare::Random
      - AllegroFlare::PlayerInputControllers::Generic


  - name: launch_ball
    parameters:
      - name: position_
        type: btVector3*
        default_argument: nullptr
      - name: velocity_
        type: btVector3*
        default_argument: nullptr
    guards: [ position_, velocity_ ]
    body: |
      const btVector3 &position = *position_;
      const btVector3 &velocity = *velocity_;
      //void MyClass::launch_ball(const btVector3 &position, const btVector3 &velocity)
      //{
      // Wake up the object if it's sleeping
      sphere_body->setActivationState(ACTIVE_TAG);

      // Reset the sphere's position
      sphere_body->setWorldTransform(btTransform(btQuaternion(0, 0, 0, 1), position));
      sphere_body->getMotionState()->setWorldTransform(btTransform(btQuaternion(0, 0, 0, 1), position));

      // Clear any previous velocity
      sphere_body->setLinearVelocity(btVector3(0, 0, 0));
      sphere_body->setAngularVelocity(btVector3(0, 0, 0));

      // Apply an impulse to "throw" the ball
      sphere_body->applyCentralImpulse(velocity);


      set_state(STATE_IN_SIMULATION);

      //}
      return;
    body_dependency_symbols:
      - btVector3


  - name: is_cube_knocked_down
    type: bool
    parameters:
      - name: cube
        type: btRigidBody*
        default_argument: nullptr
      - name: initial_height
        type: float
        default_argument: 0.0f
      - name: threshold
        type: float
        default_argument: 0.8f
    guards: [ cube ]
    body: |
      //bool is_block_knocked_down(btRigidBody* block, float initial_height, float threshold = 0.8f)
      //{
         btVector3 position = cube->getCenterOfMassPosition();
         return position.getY() < (initial_height * threshold);
      //}


  - name: count_cubes_knocked_down
    type: int
    guards: [ (cubes.size() == cube_initial_heights.size()) ]
    body: |
      int cubes_knocked_down = 0;
      for (int i=0; i<(int)cubes.size(); i++)
      {
         if (is_cube_knocked_down(cubes[i].first, cube_initial_heights[i])) cubes_knocked_down++;
      }
      return cubes_knocked_down;


  - name: create_convex_shape
    private: true
    type: btConvexHullShape*
    parameters:
      - name: model
        type: AllegroFlare::Model3D*
        default_argument: nullptr
    guards: [ model ]
    body: |
      // TODO: Confirm model is triangulated, and points are TRIANGLE_LINE_LIST
      btConvexHullShape *convex_shape = new btConvexHullShape();

      for (auto &vertex : model->vertices)
      {
          btVector3 bt_vertex(vertex.x, vertex.y, vertex.z);
          convex_shape->addPoint(bt_vertex, false); //  avoids automatic recalculation of the AABB
      }
      convex_shape->recalcLocalAabb(); // Recalculate the bounding box after all points are added
      return convex_shape;


  - name: create_dynamic_mesh_shape
    type: std::pair<btRigidBody*, btCollisionShape*>
    parameters:
      - name: model
        type: AllegroFlare::Model3D*
        default_argument: nullptr
      - name: x
        type: float
        default_argument: 0.0f
      - name: y
        type: float
        default_argument: 50.0f
      - name: z
        type: float
        default_argument: 0.0f
    guards: [ model ]
    body: |
      btConvexHullShape *convex_shape = create_convex_shape(model);

      btScalar mass = 1;  // Adjust mass as required
      btVector3 inertia(0, 0, 0);
      convex_shape->calculateLocalInertia(mass, inertia);

      btDefaultMotionState *motion_state = new btDefaultMotionState(
          //btTransform(btQuaternion(0, 0, 0, 1), btVector3(0, 50, 0))
          btTransform(btQuaternion(0, 0, 0, 1), btVector3(x, y, z))
      );

      btRigidBody::btRigidBodyConstructionInfo body_ci(
          mass,
          motion_state,
          convex_shape,
          inertia
      );

      btRigidBody *dynamic_body = new btRigidBody(body_ci);

      dynamic_body->setRestitution(0.6);

      // NOTE: The object will need to be added to the dynamics world after being returned from this method:
      //dynamics_world->addRigidBody(dynamic_body);

      return std::make_pair(dynamic_body, convex_shape);
      //return std::make_pair<btRigidBody*, btCollisionShape*>(dynamic_body, convex_shape);


  - name: step_physics
    parameters:
      - name: time_step
        type: double
        default_argument: 1.0 / 60.0
    body: |
      // Simulate physics
      //for (int i = 0; i < 150; i++)
      //{
         //dynamics_world.stepSimulation(1.0f / 60.0f, 10);
         dynamics_world->stepSimulation(time_step, 10); // TODO: Not sure what 10 is, believe it's "max substeps", but
                                                        // not sure how this applies
         btTransform trans;
         sphere_body->getMotionState()->getWorldTransform(trans);
         //std::cout << "Sphere height at step " << i << ": " << trans.getOrigin().getY() << std::endl;
      //}
      return;


  - name: output_body_positions_and_rotations
    parameters:
      - name: time_step
        type: double
        default_argument: 1.0 / 60.0
    body: |
      // Output the sphere (currently the only object in the scene)
      btTransform bullet_transform;
      sphere_body->getMotionState()->getWorldTransform(bullet_transform);
      std::cout << "Sphere height at step: " << bullet_transform.getOrigin().getY() << std::endl;
      return;


  - name: capture_sphere_body_position_and_rotation
    parameters:
      - name: position
        type: AllegroFlare::Vec3D*
        default_argument: nullptr
      - name: rotation_euler
        type: AllegroFlare::Vec3D*
        default_argument: nullptr
    guards: [ position ]
    xguards: [ position, rotation_euler ]
    body: |
      // Capture the sphere (currently the only object in the scene)
      btTransform bullet_transform;
      sphere_body->getMotionState()->getWorldTransform(bullet_transform);
      btVector3 origin = bullet_transform.getOrigin();

      position->x = origin.getX();
      position->y = origin.getY();
      position->z = origin.getZ();

      //btQuaternion rotation_quarternion = bullet_transform.getRotation();

      //rotation_euler->x = origin.getX();
      //rotation_euler->y = origin.getY();
      //rotation_euler->z = origin.getZ();

      return;


  - name: build_transform_bullet
    static: true
    parameters:
      - name: transform
        type: ALLEGRO_TRANSFORM*
        default_argument: nullptr
      - name: placement_3d
        type: AllegroFlare::Placement3D*
        default_argument: nullptr
    guards: [ transform, placement_3d ]
    body: |
      al_identity_transform(transform);

      auto &align = placement_3d->align;
      auto &size = placement_3d->size;
      auto &scale = placement_3d->scale;
      auto &anchor = placement_3d->anchor;
      auto &rotation = placement_3d->rotation;
      auto &position = placement_3d->position;

      // offset for alignment and anchors
      al_translate_transform_3d(transform, -align.x*size.x, -align.y*size.y, -align.z*size.z);
      al_scale_transform_3d(transform, scale.x, scale.y, scale.z);
      al_translate_transform_3d(transform, anchor.x, anchor.y, anchor.z);

      // rotate
      //al_rotate_transform_3d(transform, 0, 0, 1, rotation.z);
      //al_rotate_transform_3d(transform, 0, 1, 0, rotation.y);
      al_rotate_transform_3d(transform, 1, 0, 0, rotation.x);
      al_rotate_transform_3d(transform, 0, 1, 0, rotation.y);
      al_rotate_transform_3d(transform, 0, 0, 1, rotation.z);
      //al_rotate_transform_3d(transform, 0, 0, 1, rotation.z);

      // translate
      al_translate_transform_3d(transform, position.x, position.y, position.z);

      return;


  - name: capture_cube_body_position_and_rotation
    parameters:
      - name: position
        type: AllegroFlare::Vec3D*
        default_argument: nullptr
      - name: rotation_euler
        type: AllegroFlare::Vec3D*
        default_argument: nullptr
      - name: cube_index
        type: int
        default_argument: -1
    guards: [ position, rotation_euler, (cube_index >= 0), (cube_index < cubes.size()) ]
    body: |
      btRigidBody* cube_body = cubes[cube_index].first;
      //if (cube_index >= 0) cube_body = cubes[cube_index].first;
      //if (cube_index >= 0) cube_body = cubes[cube_index].first;
      
      btTransform bullet_transform;
      cube_body->getMotionState()->getWorldTransform(bullet_transform);
      btVector3 origin = bullet_transform.getOrigin();

      position->x = origin.getX();
      position->y = origin.getY();
      position->z = origin.getZ();

      btQuaternion rotation_quarternion = bullet_transform.getRotation();

      btScalar yawZ;
      btScalar pitchY;
      btScalar rollX;

      rotation_quarternion.getEulerZYX(yawZ, pitchY, rollX);
      rotation_euler->y = pitchY;
      rotation_euler->x = rollX;
      rotation_euler->z = yawZ;

      return;


  - name: capture_shape_body_position_and_rotation
    parameters:
      - name: position
        type: AllegroFlare::Vec3D*
        default_argument: nullptr
      - name: rotation_euler
        type: AllegroFlare::Vec3D*
        default_argument: nullptr
      - name: shape_index
        type: int
        default_argument: -1
    guards: [ position, rotation_euler, (shape_index >= 0), (shape_index < shapes.size()) ]
    body: |
      btRigidBody* shape_body = shapes[shape_index].first;

      capture_rigid_body_position_and_rotation(position, rotation_euler, shape_body);
      
      return;


  - name: capture_rigid_body_position_and_rotation
    parameters:
      - name: position
        type: AllegroFlare::Vec3D*
        default_argument: nullptr
      - name: rotation_euler
        type: AllegroFlare::Vec3D*
        default_argument: nullptr
      - name: rigid_body
        type: btRigidBody*
        default_argument: nullptr
    guards: [ position, rotation_euler, rigid_body ]
    body: |
      btTransform bullet_transform;
      rigid_body->getMotionState()->getWorldTransform(bullet_transform);
      btVector3 origin = bullet_transform.getOrigin();

      position->x = origin.getX();
      position->y = origin.getY();
      position->z = origin.getZ();

      btQuaternion rotation_quarternion = bullet_transform.getRotation();

      btScalar yawZ;
      btScalar pitchY;
      btScalar rollX;

      rotation_quarternion.getEulerZYX(yawZ, pitchY, rollX);
      rotation_euler->y = pitchY;
      rotation_euler->x = rollX;
      rotation_euler->z = yawZ;

      return;



  - name: ~destroy
    body: |
      if (initialized && !destroyed)
      {
         AllegroFlare::Logger::warn_from(
            "BulletPhysics::Examples::Mesh::~destroy", 
            "This instance is being destroyed but the destroy() method has not been called."
         );
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Logger


  - name: destroy
    guards: [ (!destroyed), initialized ]
    body: |
      clear();
      // Cleanup
      //dynamics_world->removeRigidBody(sphere_body);
      //delete sphere_body->getMotionState();
      //delete sphere_body;
      //delete sphere_shape;

      /*
      dynamics_world->removeRigidBody(cube_body);
      delete cube_body->getMotionState();
      delete cube_body;
      */
      //delete cube_shape;

      //dynamics_world->removeRigidBody(ground_body);
      //delete ground_body->getMotionState();
      //delete ground_body;
      //delete ground_shape;

      // TODO: Delete properties of cubes

      // Destroy the rendering
      destroy_render();

      //delete dynamics_world;
      destroyed = true;
      return;


# Overrides to Gameplay::Screens


  - name: initialize_render
    body: |
      set_update_strategy(AllegroFlare::Screens::Base::UpdateStrategy::SEPARATE_UPDATE_AND_RENDER_FUNCS);

      static bool rendering_setup = false;
      if (!rendering_setup)
      {
         //camera3d
         camera3d.stepout = AllegroFlare::Vec3D(0, 1.25, 16);
         camera3d.tilt = 0.65;
         camera3d.spin = 1.25;
         camera3d.near_plane = 0.25;
         camera3d.far_plane = 500.0;

         //hud_camera
         // NOTE: Nothing to do

         //model_bin
         model_bin.set_full_path(data_folder_path + "models");

         //bitmap_bin
         bitmap_bin.set_full_path(data_folder_path + "bitmaps");

         //font_bin
         font_bin.set_full_path(data_folder_path + "fonts");

         rendering_setup = true;
      }
      return;


  - name: destroy_render
    body: |
      //model_bin
      model_bin.clear();

      //bitmap_bin
      bitmap_bin.clear();

      //font_bin
      font_bin.clear();
      return;


  - name: primary_update_func
    virtual: true
    override: true
    parameters:
      - name: time_now
        type: double
        default_argument: 'al_get_time()'
      - name: time_step
        type: double
        default_argument: 1.0 / 60.0
    guards: [ initialized ]
    body: |
      //AllegroFlare::Screens::Gameplay::primary_update_func(time_now, time_step);
      //throw std::runtime_error("jasdiofajsiodfjasdiof");
      if (get_gameplay_suspended()) return;
      
      //throw std::runtime_error("jasdiofajsiodfjasdiof");
      step_physics(time_step * 2); // Make the time step faster with * 2 since it's coming in as 1.0/60.0
      update_state();
      // Simulate physics
      //for (int i = 0; i < 150; i++)
      //{
         //dynamics_world.stepSimulation(1.0f / 60.0f, 10);
         //dynamics_world->stepSimulation(time_step, 10); // TODO: Not sure what 10 is, believe it's "max substeps", but
                                                        // not sure how this applies
         //btTransform trans;
         //sphere_body->getMotionState()->getWorldTransform(trans);
         //std::cout << "Sphere height at step " << i << ": " << trans.getOrigin().getY() << std::endl;
      //}
      return;


  - name: primary_render_func
    virtual: true
    override: true
    guards: [ initialized ]
    body: |
      //AllegroFlare::Screens::Gameplay::primary_render_func();
      if (get_gameplay_suspended())
      {
         ALLEGRO_FONT *font = get_any_font(&font_bin);
         //get_any_font
         al_draw_multiline_text(
            font,
            ALLEGRO_COLOR{1, 1, 1, 1},
            1920/2,
            1080-80*2,
            1920,
            al_get_font_line_height(font),
            ALLEGRO_ALIGN_CENTER,
            "PAUSED"
         );
         return;
      }


      camera3d.spin -= 0.0125 * 0.25;



      AllegroFlare::Model3D *sphere_model = model_bin.auto_get("unit_sphere-01.obj");
      AllegroFlare::Model3D *cube_model = model_bin.auto_get("centered_unit_cube-03.obj");
      //AllegroFlare::Model3D *shape_model = model_bin.auto_get("obscure_unit_tetrahedron-02.obj");
      AllegroFlare::Model3D *shape_model = model_bin.auto_get("fancy_dice-01.obj");
      //AllegroFlare::Model3D *shape_model = model_bin.auto_get("dice_v-01.obj");
      cube_model->set_texture(bitmap_bin.auto_get("dice_faces-04.png"));
      //shape_model->set_texture(get_bitmap_bin_ref().auto_get("obscure_unit_tetrahedron-02.png"));
      shape_model->set_texture(bitmap_bin.auto_get("fancy_dice-02.png"));
      shape_model->set_texture(bitmap_bin.auto_get("fancy_neopets_dice-01.png"));
      shape_model->set_texture(bitmap_bin.auto_get("6_dice_sides-01b.png"));



      // Create some scene "entity" variables
      AllegroFlare::Vec3D sphere_body_position;
      //AllegroFlare::Vec3D cube_body_position;
      AllegroFlare::Vec3D sphere_body_rotation;
      AllegroFlare::Vec3D cube_body_rotation;
      AllegroFlare::Placement3D sphere_body_placement;
      AllegroFlare::Placement3D cube_body_placement;

      std::vector<AllegroFlare::Vec3D> cube_body_positions;
      std::vector<AllegroFlare::Vec3D> cube_body_rotations;
      std::vector<AllegroFlare::Placement3D> cube_body_placements;
      int _num_cubes = num_cubes();
      cube_body_positions.resize(_num_cubes);
      cube_body_rotations.resize(_num_cubes);
      cube_body_placements.resize(_num_cubes);

      std::vector<AllegroFlare::Vec3D> shape_body_positions;
      std::vector<AllegroFlare::Vec3D> shape_body_rotations;
      std::vector<AllegroFlare::Placement3D> shape_body_placements;
      int _num_shapes = num_shapes();
      shape_body_positions.resize(_num_shapes);
      shape_body_rotations.resize(_num_shapes);
      shape_body_placements.resize(_num_shapes);



            // Synchronize the physics with the visual
            this->capture_sphere_body_position_and_rotation(&sphere_body_position, &sphere_body_rotation);
            //screen.capture_cube_body_position_and_rotation(&cube_body_position, &cube_body_rotation);
            //cube_body_placement.scale = {2, 2, 2};
            for (int i=0; i<_num_cubes; i++)
            {
               this->capture_cube_body_position_and_rotation(&cube_body_positions[i], &cube_body_rotations[i], i);
               cube_body_placements[i].position = cube_body_positions[i];
               cube_body_placements[i].rotation = cube_body_rotations[i];
               //cube_body_placements[i].scale = {2, 2, 2};
            }

            for (int i=0; i<_num_shapes; i++)
            {
               this->capture_shape_body_position_and_rotation(&shape_body_positions[i], &shape_body_rotations[i], i);
               shape_body_placements[i].position = shape_body_positions[i];
               shape_body_placements[i].rotation = shape_body_rotations[i];
               //cube_body_placements[i].scale = {2, 2, 2};
            }
            

            // Update the sphere and cube placements
            sphere_body_placement.position = sphere_body_position;
            sphere_body_placement.rotation = sphere_body_rotation;
            sphere_body_placement.scale = { 2, 2, 2 };




      // Setup the 3d scene projection
      camera3d.setup_projection_on(al_get_target_bitmap());


      {
            // Draw the sphere and cube objects
            sphere_body_placement.start_transform();
            sphere_model->draw();
            sphere_body_placement.restore_transform();



            int num_cubes = this->num_cubes();
            for (int i=0; i<num_cubes; i++)
            {
               ALLEGRO_TRANSFORM previous_transform;

               if (!al_get_current_transform()) return;
               al_copy_transform(&previous_transform, al_get_current_transform());

               //this->build_transform(&transform);

               //al_compose_transform(&transform, &previous_transform);
               //al_use_transform(&transform);
               
               ALLEGRO_TRANSFORM transform;
               BulletPhysics::Examples::Knockdown::build_transform_bullet(&transform, &cube_body_placements[i]);
               al_compose_transform(&transform, &previous_transform);
               al_use_transform(&transform);
               //cube_body_placement.start_transform();


               cube_model->draw();


               //cube_body_placement.restore_transform();
               al_use_transform(&previous_transform);
            }


            int num_shapes = this->num_shapes();
            for (int i=0; i<num_shapes; i++)
            {
               ALLEGRO_TRANSFORM previous_transform;

               if (!al_get_current_transform()) return;
               al_copy_transform(&previous_transform, al_get_current_transform());

               //this->build_transform(&transform);

               //al_compose_transform(&transform, &previous_transform);
               //al_use_transform(&transform);
               
               ALLEGRO_TRANSFORM transform;
               BulletPhysics::Examples::Knockdown::build_transform_bullet(&transform, &shape_body_placements[i]);
               al_compose_transform(&transform, &previous_transform);
               al_use_transform(&transform);
               //shape_body_placement.start_transform();


               shape_model->draw();


               //shape_body_placement.restore_transform();
               al_use_transform(&previous_transform);
            }


            //cube_body_placement.position = cube_body_position;
            //camera.setup_projection_on(al_get_target_bitmap());
            //hud_camera.setup_projection_on(al_get_target_bitmap());
            int num_cubes_knocked_down = this->count_cubes_knocked_down();
            hud_camera.setup_dimensional_projection(al_get_target_bitmap());

            ALLEGRO_FONT *font = get_any_font(&font_bin);
            al_draw_multiline_textf(
               font,
               ALLEGRO_COLOR{1, 1, 1, 1},
               1920/2,
               80,
               1920,
               al_get_font_line_height(font),
               ALLEGRO_ALIGN_CENTER,
               "KNOCKED DOWN\n%d",
                  num_cubes_knocked_down
            );


               //ALLEGRO_FONT *font_x = get_font_bin_ref().auto_get("Oswald-Medium.ttf -262");
               ALLEGRO_FONT *font_x = font_bin.auto_get("Oswald-Medium.ttf -262");
            if (this->showing_final_score())
            {
               ALLEGRO_FONT *font = font_x;
               al_draw_multiline_textf(
                  font,
                  ALLEGRO_COLOR{0.4, 0.72, 0.8, 1},
                  1920/2,
                  1080/2 - al_get_font_line_height(font),
                  1920,
                  al_get_font_line_height(font),
                  ALLEGRO_ALIGN_CENTER,
                  "KNOCKED DOWN\n%d",
                     num_cubes_knocked_down
               );
            }



            // For debugging, show state
            al_draw_multiline_textf(
               font,
               ALLEGRO_COLOR{1, 1, 1, 1},
               1920/2,
               1080-80*2,
               1920,
               al_get_font_line_height(font),
               ALLEGRO_ALIGN_CENTER,
               "STATE: %d",
                  this->get_state()
            );
      }




      // Setup the hud projection
      hud_camera.setup_dimensional_projection(al_get_target_bitmap());

      // For debugging, show state
      //ALLEGRO_FONT *font = font_bin["Oswald-Medium.ttf -262"];
      ALLEGRO_FONT *font = get_any_font(&font_bin);
      //get_any_font
      al_draw_multiline_textf(
         font,
         ALLEGRO_COLOR{1, 1, 1, 1},
         1920/2,
         1080-80*2,
         1920,
         al_get_font_line_height(font),
         ALLEGRO_ALIGN_CENTER,
         "STATE: %d",
            state
      );


      return;
    body_dependency_symbols:
      - AllegroFlare::Camera3D
      - AllegroFlare::Camera2D
      - AllegroFlare::ModelBin
      - AllegroFlare::FontBin
      - AllegroFlare::BitmapBin


  - name: get_any_font
    type: ALLEGRO_FONT*
    parameters:
      - name: font_bin
        type: AllegroFlare::FontBin*
        default_argument: nullptr
      - name: size
        type: int
        default_argument: -30
    guards: [ font_bin, (size != 0) ]
    body: |
      std::stringstream ss;
      ss << "Inter-Regular.ttf " << size;
      return font_bin->auto_get(ss.str());


# State-based logic


  - name: set_state
    parameters:
      - name: state
        type: uint32_t
        default_argument: STATE_UNDEF
      - name: override_if_busy
        type: bool
        default_argument: false
    guards: [ is_valid_state(state) ]
    body: |
      if (this->state == state) return;
      if (!override_if_busy && state_is_busy) return;
      uint32_t previous_state = this->state;

      this->state = state;
      state_changed_at = al_get_time();

      switch (state)
      {
         case STATE_WAITING_FOR_PLAYER_TO_THROW_BALL:
         break;

         case STATE_IN_SIMULATION:
         break;

         case STATE_TALLYING_SCORE:
         break;

         case STATE_SCORE_TALLIED:
         break;

         /*
         case STATE_REVEALING:
         break;

         case STATE_AWAITING_USER_INPUT:
         break;

         case STATE_CLOSING_DOWN:
         break;
         */

         default:
            AllegroFlare::Logger::throw_error(
               "ClassName::set_state",
               "Unable to handle case for state \"" + std::to_string(state) + "\""
            );
         break;
      }

      //this->state = state;
      //state_changed_at = al_get_time();

      return;
    body_dependency_symbols:
      - AllegroFlare::Logger


  - name: update_state
    parameters:
      - name: time_now
        type: float
        default_argument: al_get_time()
    guards: [ is_valid_state(state) ]
    body: |
      float age = infer_current_state_age(time_now);

      switch (state)
      {
         case STATE_WAITING_FOR_PLAYER_TO_THROW_BALL:
         break;

         case STATE_IN_SIMULATION: {
            if (age > 4.0) set_state(STATE_TALLYING_SCORE);
         } break;

         case STATE_TALLYING_SCORE:
            set_state(STATE_SCORE_TALLIED);
         break;

         case STATE_SCORE_TALLIED:
         break;

         /*
         case STATE_REVEALING:
         break;

         case STATE_AWAITING_USER_INPUT:
         break;

         case STATE_CLOSING_DOWN:
         break;
         */

         default:
            AllegroFlare::Logger::throw_error(
               "ClassName::update_state",
               "Unable to handle case for state \"" + std::to_string(state) + "\""
            );
         break;
      }

      return;
    body_dependency_symbols:
      - AllegroFlare::Logger


  - name: is_valid_state
    type: bool
    static: true
    parameters:
      - name: state
        type: uint32_t
        default_argument: STATE_UNDEF
    body: |
      std::set<uint32_t> valid_states =
      {
         STATE_WAITING_FOR_PLAYER_TO_THROW_BALL,
         STATE_IN_SIMULATION,
         STATE_TALLYING_SCORE,
         STATE_SCORE_TALLIED,
         //STATE_REVEALING,
         //STATE_AWAITING_USER_INPUT,
         //STATE_CLOSING_DOWN,
      };
      return (valid_states.count(state) > 0);
    body_dependency_symbols:
      - std::set


  - name: is_state
    type: bool
    parameters:
      - name: possible_state
        type: uint32_t
        default_argument: STATE_UNDEF
    body: |
     return (state == possible_state);


  - name: infer_current_state_age
    type: float
    parameters:
      - name: time_now
        type: float
        default_argument: al_get_time()
    body: |
      return (time_now - state_changed_at);


  - name: showing_final_score
    type: bool
    body: |
      return is_state(STATE_SCORE_TALLIED);


dependencies:


  - symbol: BulletPhysics::DynamicsWorld
    headers: [ BulletPhysics/DynamicsWorld.hpp ]
  - symbol: AllegroFlare::Screens::Gameplay
    headers: [ AllegroFlare/Screens/Gameplay.hpp ]
  - symbol: bullet_physics_common
    headers: [ btBulletDynamicsCommon.h ]
  - symbol: btVector3
    headers: [ btBulletDynamicsCommon.h ]
  - symbol: btDiscreteDynamicsWorld
    headers: [ btBulletDynamicsCommon.h ]
  - symbol: btRigidBody
    headers: [ btBulletDynamicsCommon.h ]
  - symbol: btCollisionShape
    headers: [ btBulletDynamicsCommon.h ]
  - symbol: AllegroFlare::Logger
    headers: [ AllegroFlare/Logger.hpp ]
  - symbol: btCollisionDispatcher
    headers: [ btBulletDynamicsCommon.h ]
  - symbol: btDbvtBroadphase
    headers: [ btBulletDynamicsCommon.h ]
  - symbol: btDefaultCollisionConfiguration
    headers: [ btBulletDynamicsCommon.h ]
  - symbol: btSequentialImpulseConstraintSolver
    headers: [ btBulletDynamicsCommon.h ]
  - symbol: AllegroFlare::Vec3D
    headers: [ AllegroFlare/Vec3D.hpp ]
  - symbol: ALLEGRO_TRANSFORM
    headers: [ allegro5/allegro.h ]
  - symbol: AllegroFlare::Placement3D
    headers: [ AllegroFlare/Placement3D.hpp ]
  - symbol: AllegroFlare::Random
    headers: [ AllegroFlare/Random.hpp ]
  - symbol: AllegroFlare::Model3D
    headers: [ AllegroFlare/Model3D.hpp ]
  - symbol: btConvexHullShape
    headers: [ btBulletDynamicsCommon.h ]
  - symbol: AllegroFlare::PlayerInputControllers::Generic
    headers: [ AllegroFlare/PlayerInputControllers/Generic.hpp ]
  - symbol: AllegroFlare::Tiled::TMJDataLoader
    headers: [ AllegroFlare/Tiled/TMJDataLoader.hpp ]
  - symbol: BulletPhysics::Examples::Knockdown
    headers: [ BulletPhysics/Examples/Knockdown.hpp ]

# rendering-dependent dependencies:

  - symbol: AllegroFlare::Camera3D
    headers: [ AllegroFlare/Camera3D.hpp ]
  - symbol: AllegroFlare::Camera2D
    headers: [ AllegroFlare/Camera2D.hpp ]
  - symbol: AllegroFlare::ModelBin
    headers: [ AllegroFlare/ModelBin.hpp ]
  - symbol: AllegroFlare::FontBin
    headers: [ AllegroFlare/FontBin.hpp ]
  - symbol: AllegroFlare::BitmapBin
    headers: [ AllegroFlare/BitmapBin.hpp ]
  - symbol: ALLEGRO_FONT
    headers: [ allegro5/allegro_font.h ]


