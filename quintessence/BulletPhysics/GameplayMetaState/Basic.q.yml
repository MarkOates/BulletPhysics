parent_classes:


  - class: BulletPhysics::GameplayMetaState::Base
    scope: public
    init_with: BulletPhysics::GameplayMetaState::Basic::TYPE


properties:


  - name: on_closed_out_func
    type: std::function<void()>
    init_with: '{}'
    getter: true
    setter: true

  - name: dip_to_black_opacity
    type: float
    init_with: 0.0f
    getter: true

  - name: state
    type: uint32_t
    init_with: STATE_UNDEF
    getter: true
    setter: explicit

  - name: state_is_busy
    type: bool
    init_with: false

  - name: state_changed_at
    type: double
    init_with: 0.0

  - name: TYPE
    type: char*
    init_with: '(char*)"BulletPhysics/GameplayMetaState/Basic"'
    static: true
    constexpr: true


enums:


  - name: State
    enumerators:
      - STATE_UNDEF
      - STATE_WAITING_TO_START
      - STATE_OPENING_SEQUENCE
      - STATE_WAITING_FOR_PLAYER_TO_THROW_BALL
      - STATE_IN_SIMULATION
      - STATE_TALLYING_SCORE
      - STATE_SCORE_TALLIED_AND_PRESENTING
      - STATE_SCORE_PRESENTED_AND_WAITING_FOR_PLAYER_TO_CONTINUE
      - STATE_CLOSING_OUT_SCORE_TALLY_PRESENTATION
      - STATE_SCORE_TALLY_CLOSED_OUT


documentation:


  - notes:
      - This class handles and manages state designed around the most common gameplay meta-states, such as level opening
        sequences, ready banners, end-of-level score tallying, closing out, etc.


methods:


  - name: is_player_input_active
    virtual: true
    override: true
    type: bool
    body: |
      return true;


  - name: set_state
    parameters:
      - name: state
        type: uint32_t
        default_argument: STATE_UNDEF
      - name: override_if_busy
        type: bool
        default_argument: false
    guards: [ is_valid_state(state) ]
    body: |
      if (this->state == state) return;
      if (!override_if_busy && state_is_busy) return;
      uint32_t previous_state = this->state;

      this->state = state;
      state_changed_at = al_get_time();

      switch (state)
      {
         case STATE_WAITING_TO_START: {
         } break;

         case STATE_OPENING_SEQUENCE: {
            dip_to_black_opacity = 1.0f;
         } break;

         case STATE_WAITING_FOR_PLAYER_TO_THROW_BALL: {
         } break;

         case STATE_IN_SIMULATION: {
         } break;

         case STATE_TALLYING_SCORE: {
         } break;

         case STATE_SCORE_TALLIED_AND_PRESENTING: {
         } break;

         case STATE_SCORE_PRESENTED_AND_WAITING_FOR_PLAYER_TO_CONTINUE: {
         } break;

         case STATE_CLOSING_OUT_SCORE_TALLY_PRESENTATION: {
            dip_to_black_opacity = 0.0f;
         } break;

         case STATE_SCORE_TALLY_CLOSED_OUT: {
            dip_to_black_opacity = 1.0f;
            if (on_closed_out_func) on_closed_out_func();
            //clear();
            //reset();
         } break;

         /*
         case STATE_REVEALING:
         break;

         case STATE_AWAITING_USER_INPUT:
         break;

         case STATE_CLOSING_DOWN:
         break;
         */

         default: {
            AllegroFlare::Logger::throw_error(
               "BulletPhysics::GameplayMetaState::Basic::set_state",
               "Unable to handle case for state \"" + std::to_string(state) + "\""
            );
         } break;
      }

      return;
    body_dependency_symbols:
      - AllegroFlare::Logger
      - al_get_time


  - name: update_state
    parameters:
      - name: time_now
        type: double
        default_argument: al_get_time()
        default_argument_dependency_symbols: [ al_get_time ]
      - name: time_step
        type: double
        default_argument: (1.0/60.0f)
    guards: [ is_valid_state(state) ]
    body: |
      double real_age = infer_current_state_real_age(time_now);

      switch (state)
      {
         case STATE_WAITING_TO_START: {
         } break;

         case STATE_OPENING_SEQUENCE: {
            dip_to_black_opacity -= 0.025f;
            if (real_age > 2.0)
            {
               dip_to_black_opacity = 0.0f;
               set_state(STATE_WAITING_FOR_PLAYER_TO_THROW_BALL);
            }
         } break;

         case STATE_WAITING_FOR_PLAYER_TO_THROW_BALL: {
         } break;

         case STATE_IN_SIMULATION: {
            if (real_age > 4.0) set_state(STATE_TALLYING_SCORE);
         } break;

         case STATE_TALLYING_SCORE: {
            if (real_age > 2.0) set_state(STATE_SCORE_TALLIED_AND_PRESENTING);
         } break;

         case STATE_SCORE_TALLIED_AND_PRESENTING: {
            if (real_age > 1.0) set_state(STATE_SCORE_PRESENTED_AND_WAITING_FOR_PLAYER_TO_CONTINUE);
         } break;

         case STATE_SCORE_PRESENTED_AND_WAITING_FOR_PLAYER_TO_CONTINUE: {
         } break;

         case STATE_CLOSING_OUT_SCORE_TALLY_PRESENTATION: {
            dip_to_black_opacity += 0.025f;
            if (real_age > 1.0) set_state(STATE_SCORE_TALLY_CLOSED_OUT);
         } break;

         case STATE_SCORE_TALLY_CLOSED_OUT: {
            // TODO: Consider if "on_finished" is needed here
            dip_to_black_opacity = 1.0f;
         } break;

         default:
            AllegroFlare::Logger::throw_error(
               "ClassName::update_state",
               "Unable to handle case for state \"" + std::to_string(state) + "\""
            );
         break;
      }

      return;
    body_dependency_symbols:
      - AllegroFlare::Logger


  - name: is_valid_state
    type: bool
    static: true
    parameters:
      - name: state
        type: uint32_t
        default_argument: STATE_UNDEF
    body: |
      std::set<uint32_t> valid_states =
      {
         STATE_WAITING_TO_START,
         STATE_OPENING_SEQUENCE,
         STATE_WAITING_FOR_PLAYER_TO_THROW_BALL,
         STATE_IN_SIMULATION,
         STATE_TALLYING_SCORE,
         STATE_SCORE_TALLIED_AND_PRESENTING,
         STATE_SCORE_PRESENTED_AND_WAITING_FOR_PLAYER_TO_CONTINUE,
         STATE_CLOSING_OUT_SCORE_TALLY_PRESENTATION,
         STATE_SCORE_TALLY_CLOSED_OUT,
      };
      return (valid_states.count(state) > 0);
    body_dependency_symbols:
      - std::set


  - name: is_state
    type: bool
    parameters:
      - name: possible_state
        type: uint32_t
        default_argument: STATE_UNDEF
    body: |
     return (state == possible_state);


  - name: infer_current_state_real_age
    type: double
    parameters:
      - name: time_now
        type: double
        default_argument: al_get_time()
    body: |
      return (time_now - state_changed_at);


  - name: showing_final_score
    type: bool
    body: |
      return
         is_state(STATE_TALLYING_SCORE)
         || is_state(STATE_SCORE_TALLIED_AND_PRESENTING)
         || is_state(STATE_SCORE_PRESENTED_AND_WAITING_FOR_PLAYER_TO_CONTINUE);


  - name: showing_ready_banner
    type: bool
    body: |
      return is_state(STATE_OPENING_SEQUENCE);


  - name: showing_gamplay_instructions
    type: bool
    body: |
      return is_state(STATE_WAITING_FOR_PLAYER_TO_THROW_BALL);


  - name: showing_press_any_key_to_continue_after_score_tally
    type: bool
    body: |
      return is_state(STATE_SCORE_PRESENTED_AND_WAITING_FOR_PLAYER_TO_CONTINUE);


  - name: waiting_for_player_input_to_continue
    type: bool
    body: |
      return is_state(STATE_SCORE_PRESENTED_AND_WAITING_FOR_PLAYER_TO_CONTINUE);


  - name: continue_from_waiting_for_player_input_to_continue
    body: |
      set_state(STATE_CLOSING_OUT_SCORE_TALLY_PRESENTATION);


dependencies:


  - symbol: BulletPhysics::GameplayMetaState::Base
    headers: [ BulletPhysics/GameplayMetaState/Base.hpp ]
  - symbol: AllegroFlare::Logger
    headers: [ AllegroFlare/Logger.hpp ]
  - symbol: al_get_time
    headers: [ allegro5/allegro.h ]


